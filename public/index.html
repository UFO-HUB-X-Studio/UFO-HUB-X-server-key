<script>
  /* ===== CONFIG ===== */
  const START_URL    = "https://direct-link.net/1398143/IGoZdaaTcIHW";
  const DOMAIN_OK    = location.hostname;
  const RETURN_KEY   = "ufo_return_ts";
  const LAST_ACTION  = "ufo_last_action";
  const EXTEND_PENDING = "ufo_extend_pending";

  const MIN_VISIT    = 5000;
  const UFO_MS       = 4000;
  const BASE_HOURS   = 48;
  const EXTEND_HOURS = 5;

  const LOCK_KEY     = "ufo_start_locked_until";
  const USER_ID_KEY  = "ufo_user_id";
  const KEY_STORE    = "ufo_key_store_v1";
  const CONFIG_URL   = "https://raw.githubusercontent.com/UFO-HUB-X-Studio/UFO-HUB-X-server-key/refs/heads/main/config.json";

  const SPLASH_MS    = 10000;
  const SPLASH_FLAG  = "ufo_splash_shown";
  const SPLASH_SKIP  = "ufo_skip_splash_once";
  const SPLASH_SKIP_LS = "ufo_skip_splash_once_ls";
  const MUST_START   = "ufo_must_start_once";

  /* ===== Elements ===== */
  const bar       = document.getElementById('bar');
  const barWrap   = document.getElementById('barWrap');
  const barUfo    = document.getElementById('barUfo');
  const pText     = document.getElementById('progressText');
  const percentEl = document.getElementById('percentText');
  const startBtn  = document.getElementById('startBtn');
  const getKeyBtn = document.getElementById('getKey');
  const keyRows   = document.getElementById('keyRows');

  const splash       = document.getElementById('splash');
  const splashCircle = document.getElementById('splashCircle');
  const splashNum    = document.getElementById('splashNum');

  let raf = null, lockTimer=null, keyTimer=null;
  let isCompleted = false;
  let btnAdd5Ref = null;
  const LEAD = 8;

  /* ===== utils ===== */
  const now = ()=>Date.now();
  const hms = (ms)=>{ if(ms<0)ms=0; const s=Math.floor(ms/1000);const h=Math.floor(s/3600),m=Math.floor((s%3600)/60),ss=s%60; return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; };

  function uid(){
    try{
      let id = localStorage.getItem(USER_ID_KEY);
      if(!id){ id = Math.random().toString(36).slice(2)+Date.now().toString(36); localStorage.setItem(USER_ID_KEY,id); }
      return id;
    }catch(e){ return 'anon'; }
  }
  function getStore(){ try{ return JSON.parse(localStorage.getItem(KEY_STORE)||'{}'); }catch(e){ return {}; } }
  function setStore(o){ try{ localStorage.setItem(KEY_STORE, JSON.stringify(o)); }catch(e){} }
  function getMyKey(){ return getStore()[uid()] || null; }
  function setMyKey(d){ const s=getStore(); s[uid()]=d; setStore(s); }
  function clearMyKey(){ const s=getStore(); delete s[uid()]; setStore(s); }

  /* ===== Progress & UFO ===== */
  function setProgress(p){
    if (p<0)p=0; if(p>100)p=100;
    bar.style.width = p+'%';
    const barRect=bar.getBoundingClientRect(), wrapRect=barWrap.getBoundingClientRect();
    const tipInside = (barRect.left+barRect.width)-wrapRect.left;
    barUfo.style.left = (tipInside + LEAD) + 'px';
    percentEl.textContent = p.toFixed(0)+'%';
    pText.textContent = 'Progress: ' + (p>=100 ? '1/1':'0/1');

    if (p>=100 && !isCompleted){
      isCompleted = true;
      startBtn.classList.add('ok');
      startBtn.disabled = true;
      startBtn.textContent = '✅';
      enableOnlyGetKey();

      if (localStorage.getItem(EXTEND_PENDING)==='1'){
        localStorage.removeItem(EXTEND_PENDING);
        autoExtend5h();
      }
    }
  }
  function runProgress(pTarget=100, duration=UFO_MS){
    cancelAnimationFrame(raf);
    barUfo.classList.add('on');
    const pStart=parseFloat(bar.style.width)||0, t0=performance.now();
    function tick(ts){ const t=Math.min(1,(ts-t0)/duration); setProgress(pStart+(pTarget-pStart)*t); if(t<1){ raf=requestAnimationFrame(tick);} }
    raf=requestAnimationFrame(tick);
  }

  /* ===== Return & gating ===== */
  function isValidReturn(){
    try{
      const ts = parseInt(localStorage.getItem(RETURN_KEY)||"0",10);
      return ts && (now()-ts)>=MIN_VISIT;
    }catch(e){ return false; }
  }
  function clearReturnMark(){ try{ localStorage.removeItem(RETURN_KEY); }catch(e){} }

  function onReturnedFromLink(){
    if(!isValidReturn()) return false;
    clearReturnMark();

    const action = localStorage.getItem(LAST_ACTION)||'';
    if (action === 'extend'){
      localStorage.removeItem(LAST_ACTION);
      autoExtend5h();
      return true;
    }
    if (action === 'start'){
      localStorage.setItem(MUST_START,'1');
      localStorage.removeItem(LAST_ACTION);
      updateGetKeyButtonState();
      runProgress(100, UFO_MS);
      return true;
    }
    runProgress(100, UFO_MS);
    return true;
  }

  /* ===== START lock ===== */
  function applyLockUI(until){
    const left = until - now();
    if(left>0){ startBtn.disabled=true; startBtn.classList.remove('ok'); startBtn.classList.add('lock'); startBtn.textContent=`⛔ ${hms(left)}`; }
    else { startBtn.classList.remove('lock'); if(!isCompleted){ startBtn.disabled=false; startBtn.textContent='🟢 START'; } try{ localStorage.removeItem(LOCK_KEY);}catch(e){} }
  }
  function startLockCountdown(until){
    if(lockTimer) clearInterval(lockTimer);
    applyLockUI(until);
    lockTimer=setInterval(()=>{ applyLockUI(until); if(now()>=until){ clearInterval(lockTimer);} },1000);
  }

  /* ===== Key UI ===== */
  function renderKeyRow(data){
    keyRows.innerHTML='';
    const tr=document.createElement('tr');
    const tdKey=document.createElement('td');
    const tdLeft=document.createElement('td');
    const tdStat=document.createElement('td');
    const tdAct=document.createElement('td');
    tdKey.style.fontWeight='900'; tdKey.style.letterSpacing='1px';

    tdKey.textContent=data.key;
    tdStat.innerHTML='<span class="pill">ACTIVE</span>';

    const actions=document.createElement('div'); actions.className='actions';
    const btnCopy=document.createElement('button'); btnCopy.className='btn btn-ghost'; btnCopy.innerHTML='📋 Copy';
    const btnAdd5=document.createElement('button'); btnAdd5.className='btn btn-green'; btnAdd5.innerHTML='⏩ +5H';
    btnAdd5Ref = btnAdd5;
    actions.appendChild(btnCopy); actions.appendChild(btnAdd5); tdAct.appendChild(actions);

    function tickLeft(){
      const left=data.until - now();
      tdLeft.textContent = left>0 ? hms(left) : '00:00:00';
      if(left<=0){
        clearInterval(keyTimer);
        clearMyKey();
        updateGetKeyButtonState();
        applyLockUI(0);
      }
    }
    tickLeft();
    if(keyTimer) clearInterval(keyTimer);
    keyTimer=setInterval(tickLeft,1000);

    btnCopy.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(data.key); btnCopy.textContent='✅ Copied'; setTimeout(()=>btnCopy.innerHTML='📋 Copy',1200);}catch(e){ alert('Copy failed'); }
    });

    btnAdd5.addEventListener('click', ()=>{
      const mine=getMyKey();
      if(!mine || now()>=mine.until) return;
      try{
        sessionStorage.setItem(SPLASH_SKIP,'1');
        localStorage.setItem(SPLASH_SKIP_LS,'1');
        localStorage.setItem(RETURN_KEY, String(now()));
        localStorage.setItem(EXTEND_PENDING,'1');
        localStorage.setItem(LAST_ACTION,'extend');
      }catch(e){}
      window.location.href = START_URL;
    });

    tr.appendChild(tdKey); tr.appendChild(tdLeft); tr.appendChild(tdStat); tr.appendChild(tdAct);
    keyRows.prepend(tr);
  }

  function autoExtend5h(){
    const mine=getMyKey();
    if(!mine || now()>=mine.until) return;
    mine.until += EXTEND_HOURS*60*60*1000;
    setMyKey(mine);
    localStorage.setItem(LOCK_KEY,String(mine.until));
    startLockCountdown(mine.until);
    renderKeyRow(mine);
  }

  function enableOnlyGetKey(){
    document.querySelectorAll('button').forEach(b=>{ if(b!==getKeyBtn) b.disabled=true; });
    getKeyBtn.disabled=false;
  }

  /* ===== ดึงคีย์จาก config.json (fallback) ===== */
  function normalizeKey(k){
    let s = String(k||'').trim();
    if(!s) return '';
    if(!/^UFO[-]/i.test(s)) s = 'UFO-' + s.replace(/^\-+/,'');
    if(!/[-]48H$/i.test(s)) s = s.replace(/-48H$/i,'') + '-48H';
    return s.toUpperCase();
  }
  async function fetchKeyFromConfig(){
    try{
      const res = await fetch(CONFIG_URL,{cache:'no-store'});
      const json = await res.json();
      let list = Array.isArray(json)?json:(Array.isArray(json.keys)?json.keys:[]);
      list = list.map(normalizeKey).filter(x=>x.length>0);
      if(list.length){ return list[Math.floor(Math.random()*list.length)]; }
    }catch(e){}
    const chars='ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let s='UFO-'; for(let i=0;i<8;i++) s+=chars[Math.floor(Math.random()*chars.length)];
    return s+'-48H';
  }

  /* ===== ดึงคีย์จากเซิร์ฟเวอร์จริง (/getkey) ===== */
  async function fetchKeyFromServer(uidParam, placeParam){
    // พยายามเรียก endpoint ของเซิร์ฟเวอร์ (same origin)
    try{
      const base = location.origin; // ปรับถ้าจำเป็น ให้เป็น URL ของ server แทน location.origin
      const qs = `/getkey?uid=${encodeURIComponent(uidParam)}&place=${encodeURIComponent(placeParam)}`;
      const url = base + qs;
      const res = await fetch(url, { cache: 'no-store' , credentials: 'omit' });
      if(!res.ok) throw new Error('http_error:' + res.status);
      const data = await res.json();
      if(data && data.ok && data.key){
        // server ให้ expires_at เป็น unix seconds (ตามตัวอย่าง) -> แปลงเป็น ms
        let until = Date.now() + BASE_HOURS*60*60*1000;
        if(data.expires_at) {
          const expSec = Number(data.expires_at) || 0;
          if(expSec>1000000000) until = expSec * 1000;
        } else {
          // fallback: ถ้าไม่มี expires_at ให้ใช้ TTL 48 ชม.
          until = Date.now() + BASE_HOURS*60*60*1000;
        }
        return { ok:true, key: String(data.key), until };
      } else {
        return { ok:false, reason: data && data.reason ? data.reason : 'invalid_response' };
      }
    }catch(err){
      console.warn('fetchKeyFromServer error', err);
      return { ok:false, reason:err.message || 'network_error' };
    }
  }

  /* ===== Splash logic ===== */
  function shouldShowSplash(){
    if (sessionStorage.getItem(SPLASH_SKIP) === '1'){ sessionStorage.removeItem(SPLASH_SKIP); return false; }
    if (localStorage.getItem(SPLASH_SKIP_LS) === '1'){ localStorage.removeItem(SPLASH_SKIP_LS); return false; }
    if (sessionStorage.getItem(SPLASH_FLAG) === '1') return false;
    return true;
  }
  function showSplash(){
    splash.classList.add('show');
    const R = 65, C = 2*Math.PI*R;
    splashCircle.setAttribute('stroke-dasharray', `0 ${C}`);
    splashNum.textContent = '0%';
    const t0 = performance.now();
    function tick(ts){
      const t = Math.min(1, (ts - t0)/SPLASH_MS);
      const pct = Math.round(t*100);
      splashNum.textContent = pct + '%';
      const dash = C * t;
      splashCircle.setAttribute('stroke-dasharray', `${dash} ${C}`);
      if (t < 1) requestAnimationFrame(tick); else hideSplash();
    }
    requestAnimationFrame(tick);
  }
  function hideSplash(){
    splash.classList.remove('show');
    sessionStorage.setItem(SPLASH_FLAG,'1');
  }

  /* ===== Gating: ต้องเคย START ก่อนถึงจะสร้างคีย์ได้ ===== */
  function updateGetKeyButtonState(){
    const haveStartedOnce = localStorage.getItem(MUST_START)==='1';
    const mine = getMyKey();
    const active = !!(mine && now()<mine.until);
    if (!haveStartedOnce && !active){
      getKeyBtn.disabled = true;
      getKeyBtn.textContent = '🔒 START first';
    }else{
      getKeyBtn.disabled = active;
      getKeyBtn.textContent = active ? '🔒 WAIT' : '+ GET A NEW KEY';
    }
  }

  /* ===== Events ===== */
  startBtn.addEventListener('click', ()=>{
    if (startBtn.disabled) return;
    try {
      sessionStorage.setItem(SPLASH_SKIP,'1');
      localStorage.setItem(SPLASH_SKIP_LS,'1');
      localStorage.setItem(RETURN_KEY, String(now()));
      localStorage.setItem(LAST_ACTION,'start');
    } catch(e){}
    window.location.href = START_URL;
  });

  // + GET A NEW KEY — **เรียกเซิร์ฟเวอร์จริง** และใช้คีย์ที่ server ส่งมาเท่านั้น
  getKeyBtn.addEventListener('click', async ()=>{
    // ต้องเคยกด START อย่างน้อย 1 ครั้งก่อน
    if (localStorage.getItem(MUST_START) !== '1') {
      getKeyBtn.disabled = true;
      getKeyBtn.textContent = '🔒 START first';
      setTimeout(updateGetKeyButtonState, 1200);
      return;
    }

    const existing = getMyKey();
    if (existing && now() < existing.until) {
      updateGetKeyButtonState();
      return;
    }

    // เตรียม UI (รีเซ็ตแต่ยังไม่สร้างคีย์เอง)
    isCompleted = false;
    bar.style.width = '0%';
    percentEl.textContent = '0%';
    pText.textContent = 'Progress: 0/1';
    barUfo.classList.remove('on');
    startBtn.classList.remove('ok','lock');
    startBtn.disabled = false;
    startBtn.textContent = '🟢 START';

    // หาค่า uid และ place จาก query string (ถ้ามี) — ถ้าไม่มีให้ใช้ uid() และ place = "0"
    const params = new URLSearchParams(location.search);
    const uidParam = params.get('uid') || uid();
    const placeParam = params.get('place') || (params.get('place') === null ? '0' : params.get('place'));

    // โทรเรียก /getkey ที่เซิร์ฟเวอร์ (same origin) — ถ้าต้องการใช้ server คนละโดเมน ให้แก้ base ใน fetchKeyFromServer()
    getKeyBtn.disabled = true;
    getKeyBtn.textContent = '⏳ Requesting...';

    const result = await fetchKeyFromServer(uidParam, placeParam);

    if (result && result.ok){
      // เอาคีย์จาก server มาใช้ 100%
      const key = String(result.key);
      const until = Number(result.until) || (Date.now() + BASE_HOURS*60*60*1000);

      setMyKey({ key, until, createdAt: now() });
      localStorage.setItem(LOCK_KEY, String(until));
      startLockCountdown(until);

      getKeyBtn.disabled = true;
      getKeyBtn.textContent = '🔒 WAIT';
      renderKeyRow({ key, until });

      // ถ้ต้องการให้ UI คัดลอกลิงก์หน้า UI ของ server ด้วย ให้เรียก setClipboard ฯลฯ ที่นี่ได้
    } else {
      // ล้มเหลว เรียก fallback (สุ่มจาก config) — แต่แจ้งผู้ใช้
      console.warn('server getkey failed:', result && result.reason);
      // ใช้ fallback เดิมเป็นทางเลือก ถ้าอยากให้ "ต้องได้จาก server เท่านั้น" ให้ลบบล็อก fallback นี้
      const key = normalizeKey(await fetchKeyFromConfig());
      const until = now() + BASE_HOURS*60*60*1000;

      setMyKey({ key, until, createdAt: now() });
      localStorage.setItem(LOCK_KEY, String(until));
      startLockCountdown(until);

      getKeyBtn.disabled = true;
      getKeyBtn.textContent = '⚠️ Local key used';
      renderKeyRow({ key, until });

      // อัปเดตปุ่มกลับเป็นปกติเล็กน้อย
      setTimeout(()=>{ updateGetKeyButtonState(); }, 1600);
    }
  });

  /* ===== Boot ===== */
  document.addEventListener('DOMContentLoaded', ()=>{
    if (shouldShowSplash()) showSplash();

    setProgress(0);
    onReturnedFromLink();

    const mine = getMyKey();
    if (mine) {
      renderKeyRow(mine);
      const left = mine.until - now();
      getKeyBtn.disabled = left > 0;
      getKeyBtn.textContent = left > 0 ? '🔒 WAIT' : '+ GET A NEW KEY';
      localStorage.setItem(LOCK_KEY, String(mine.until));
      startLockCountdown(mine.until);
    } else {
      updateGetKeyButtonState();
      applyLockUI(0);
    }
  });

  window.addEventListener('pageshow', ()=>{ onReturnedFromLink(); });

  /* ===== Preload รูป ===== */
  new Image().src='https://i.postimg.cc/26L3yJ1g/file-00000000385861fab9ee0612cc0dca89.png';
  new Image().src='https://i.postimg.cc/KcdBP7Fn/20250916-152130.png';
  new Image().src='https://i.postimg.cc/hG6Pkr2s/Background-Eraser-20250916-190732755.png';
        </script>
